<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Formatting Tool</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        /* Custom styles */
        .copy-button {
            position: absolute;
            top: 8px;
            right: 8px;
            cursor: pointer;
        }

        /* Popup styles */
        #popup {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }

        #popup-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            width: 90%;
            max-width: 800px;
            height: 90%; /* Further increased height */
            max-height: 800px;
            overflow-y: auto;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
        }

        #closePopup {
            align-self: flex-end;
            margin-top: 10px;
        }

        #validationResults {
            flex: 1;
            margin-bottom: 10px;
            width: 100%;
            height: 90%; /* Further increased height */
            font-size: 12px; /* Further decreased font size */
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            resize: none; /* Disable textarea resizing */
            color: black; /* Default text color */
        }

        /* Color classes */
        .success {
            color: green;
        }

        .failure {
            color: red;
        }
    </style>
</head>
<body class="bg-gray-100">
    <div class="container mx-auto p-8">
        <h1 class="text-3xl font-bold mb-8">Text Formatting Tool</h1>
        <div>
            <label for="inputText" class="block mb-2 font-medium">Paste your content:</label>
            <textarea id="inputText" class="w-full h-40 px-4 py-2 rounded-md border-gray-300 focus:outline-none focus:border-blue-500"></textarea>
        </div>
        <button id="formatButton" class="mt-4 px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:bg-blue-600 animate-bounce">Format Text</button>
        <div class="relative mt-8">
            <label for="outputText" class="block mb-2 font-medium">Formatted text:</label>
            <textarea id="outputText" class="w-full h-96 px-4 py-2 rounded-md border-gray-300 focus:outline-none focus:border-blue-500 relative" readonly></textarea>
            <span id="copyButton" class="copy-button text-gray-600 cursor-pointer">Copy</span>
        </div>
    </div>

    <!-- Popup box -->
    <div id="popup">
        <div id="popup-content" class="bg-white rounded-lg p-8">
            <h2 class="text-2xl font-bold mb-4">Formatted Text</h2>
            <textarea id="validationResults" class="w-full h-80 px-4 py-2 rounded-md border-gray-300 focus:outline-none focus:border-blue-500" readonly></textarea>
            <button id="closePopup" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:bg-blue-600">Close</button>
        </div>
    </div>



    <script>

        // Existing functions
        document.getElementById('formatButton').addEventListener('click', function() {
            const inputText = document.getElementById('inputText').value;
            formatText(inputText);
            analyzeText(inputText);
        });

        document.getElementById('copyButton').addEventListener('click', function() {
            const outputText = document.getElementById('outputText');
            outputText.select();
            document.execCommand('copy');
            document.getElementById('copyButton').innerText = 'Copied';
            setTimeout(function() {
                document.getElementById('copyButton').innerText = 'Copy';
            }, 2000); // Change back to 'Copy' after 2 seconds
        });

        document.getElementById('closePopup').addEventListener('click', function() {
            document.getElementById('popup').style.display = 'none';
        });

        function getAllIndices(input, searchStr) {
            const indices = [];
            let index = input.toLowerCase().indexOf(searchStr.toLowerCase());
            while (index !== -1) {
                indices.push(index);
                index = input.toLowerCase().indexOf(searchStr.toLowerCase(), index + 1);
            }
            return indices;
        }

        // New functions
        function splitAlpha(inputText) {
    // Regular expression to match a digit followed by an alphabet character
    const regex = /(\d)([a-zA-Z])/g;

    // Replace each occurrence of a digit followed by an alphabet character with digit + space + alphabet character
    const formattedText = inputText.replace(regex, '$1 $2');

    return formattedText;
}


        function wordExtend(inputText) {
    const replacements = {
        'qty': 'quantity',
        'ins': 'inspection',
        'sp': 'scrap',
        'ro': 'runout',
        'rw': 'rework',
        'pr': 'production',
        'dt': 'details',
        'fi': 'final',
        'mc': 'machining',
        'num': 'number'
    };

    // Create a regular expression pattern to match each key in replacements
    const pattern = new RegExp('\\b(' + Object.keys(replacements).join('|') + ')\\b', 'gi');

    // Replace each matched key with its corresponding value
    const formattedText = inputText.replace(pattern, match => replacements[match.toLowerCase()]);

    return formattedText;
}


        function wordAttach(inputText) {
    const specifiedWords = ['production', 'inspection', 'runout', 'ok', 'rework', 'scrap'];

    // Split the input text into an array of lines
    const lines = inputText.split('\n');

    // Iterate through each line
    for (let i = 0; i < lines.length; i++) {
        // Check if the line does not contain '*' and includes '-'
        if (!lines[i].includes('*') && lines[i].includes('-')) {
            // Iterate through each specified word
            for (const word of specifiedWords) {
                const regex = new RegExp(`\\b${word}\\b`, 'gi');

                // Check if the word exists in the line, ignoring case
                if (lines[i].match(regex)) {
                    // Check if 'Total' is not already present before the word
                    if (!lines[i].toLowerCase().includes('total')) {
                        lines[i] = lines[i].replace(regex, 'Total $&');
                    }

                    // Check if 'quantity' is not already present after the word
                    if (!lines[i].toLowerCase().includes('quantity')) {
                        lines[i] = lines[i].replace(regex, '$& quantity');
                    }
                }
            }
        }
    }

    // Join the lines back into a single string
    const formattedText = lines.join('\n');
    return formattedText;
}



        function addStar(inputText) {
    // Split the input text into an array of lines
    const lines = inputText.split('\n');

    // Iterate through each line
    for (let i = 0; i < lines.length; i++) {
        // Check if the line contains the words 'model' or 'details'
        if (lines[i].toLowerCase().includes('model') || lines[i].toLowerCase().includes('details')) {
            // Check if the line does not start with '*'
            if (lines[i].trim().charAt(0) !== '*') {
                // Add '*' symbol to the beginning of the line
                lines[i] = '* ' + lines[i].trim();
            }
            // Check if the line does not end with '*'
            if (lines[i].trim().slice(-1) !== '*') {
                // Add '*' symbol to the end of the line
                lines[i] = lines[i].trim() + ' *';
            }
        }
    }

    // Join the lines back into a single string
    const formattedText = lines.join('\n');
    return formattedText;
}


        function addSpacing(inputText) {
    // Define special characters
    const specialCharacters = ['!', '"', '#', '$', '%', '&', "'", '(', ')', '*', '+', ',', '-', '.', '/', ':', ';', '<', '=', '>', '?', '@', '[', '\\', ']', '^', '_', '`', '{', '|', '}', '~'];

    // Split the input text into an array of characters
    const characters = inputText.split('');

    // Iterate through each character starting from the second character
    for (let i = 1; i < characters.length - 1; i++) {
        const currentChar = characters[i];

        // Check if the current character is a special character
        if (specialCharacters.includes(currentChar)) {
            const prevChar = characters[i - 1];
            const nextChar = characters[i + 1];

            // Check if either the previous or next character is not a whitespace
            if (prevChar.trim() !== '' || nextChar.trim() !== '') {
                // Insert a whitespace before and after the special character
                characters[i] = ' ' + currentChar + ' ';
            }
        }
    }

    // Join the characters back into a single string
    const formattedText = characters.join('');
    return formattedText;
}


        function addBulletin(inputText) {
    // Split the input text into an array of lines
    const lines = inputText.split('\n');

    // Iterate through each line
    for (let i = 0; i < lines.length; i++) {
        // Check if the line contains 'scrap details' or 'rework details' in any case
        if (lines[i].toLowerCase().includes('scrap details') || lines[i].toLowerCase().includes('rework details')) {
            // Start from the next line
            let j = i + 1;
            // Iterate through subsequent lines until an empty line is encountered or there is no alphabet character
            while (j < lines.length && lines[j].trim() !== '' && /[a-zA-Z]/.test(lines[j])) {
                // Check if there is no bullet symbol in the line
                if (!lines[j].includes('•')) {
                    // Add the bullet symbol with 6-space indentation
                    lines[j] = '      • ' + lines[j].trim();
                }
                j++;
            }
        }
    }

    // Join the lines back into a single string
    const formattedText = lines.join('\n');
    return formattedText;
}



        function lineCapitalize(inputText) {
    // Split the input text into an array of lines
    const lines = inputText.split('\n');

    // Iterate through each line
    for (let i = 0; i < lines.length; i++) {
        // Trim the line to remove leading and trailing whitespaces
        const trimmedLine = lines[i].trim();

        // Check if the line is not empty
        if (trimmedLine.length > 0) {
            // Find the index of the first alphabet letter
            const firstAlphabetIndex = trimmedLine.search(/[a-zA-Z]/);

            // Check if the first alphabet letter is not already capitalized
            if (firstAlphabetIndex !== -1 && trimmedLine[firstAlphabetIndex] === trimmedLine[firstAlphabetIndex].toLowerCase()) {
                // Capitalize the first alphabet letter
                lines[i] = lines[i].substring(0, firstAlphabetIndex) + trimmedLine[firstAlphabetIndex].toUpperCase() + trimmedLine.substring(firstAlphabetIndex + 1);
            }
        }
    }

    // Join the lines back into a single string
    const formattedText = lines.join('\n');
    return formattedText;
}


        function addNos(inputText) {
    // Split the input text into an array of lines
    const lines = inputText.split('\n');

    // Iterate through every line
    for (let i = 0; i < lines.length; i++) {
        // Check if the line contains the word 'total' or 'quantity'
        if (lines[i].toLowerCase().includes('total') || lines[i].toLowerCase().includes('quantity')) {
            // Check if the line contains a number
            if (/\d/.test(lines[i])) {
                // Check if the line does not contain 'nos' or 'nil' at the end
                if (!/\bnos\b/i.test(lines[i]) && !/\bnil\b/i.test(lines[i])) {
                    // Add "Nos" at the end of the line
                    lines[i] += " nos";
                }
            }
        }
    }

    // Join the lines back into a single string
    const formattedText = lines.join('\n');
    return formattedText;
}


function addNil(inputText) {
    // Split the input text into an array of lines
    const lines = inputText.split('\n');

    // Iterate through each line
    for (let i = 0; i < lines.length; i++) {
        // Trim the line to remove leading and trailing whitespaces
        const trimmedLine = lines[i].trim();

        // Check if the last character of the trimmed line is a hyphen
        if (trimmedLine.charAt(trimmedLine.length - 1) === '-') {
            // Add "Nil" to the end of the line
            lines[i] = trimmedLine + " Nil";
        }
    }

    // Join the lines back into a single string
    const formattedText = lines.join('\n');
    return formattedText;
}


        function doubleDigit(inputText) {
    // Replace single digits with double digits using regular expression
    const formattedText = inputText.replace(/\b(\d)\b/g, '0$1');

    return formattedText;
}


        function formatText(inputText) {
            // Integrate new formatting functions
            let formattedText ='';
            
            formattedText = splitAlpha(inputText);
            formattedText = wordExtend(formattedText);
            formattedText = wordAttach(formattedText);
            formattedText = addStar(formattedText);
            formattedText = addSpacing(formattedText);
            formattedText = addBulletin(formattedText);
            formattedText = lineCapitalize(formattedText);
            formattedText = addNos(formattedText);
            formattedText = addNil(formattedText);
            formattedText = doubleDigit(formattedText);

           document.getElementById('outputText').value = formattedText;
        }

        function analyzeText(inputText) {
            // Preserve existing validation functionality
            let output = analyzeComponent(inputText, 'scrap');
            output += '\n\n' + analyzeComponent(inputText, 'rework');
            output += '\n\n' + analyzeComstarNumbering(inputText);

            document.getElementById('validationResults').value = output;
            document.getElementById('popup').style.display = 'block';
        }

        function analyzeComponent(inputText, component) {
            // Find all occurrences of "Model"
            const modelIndices = getAllIndices(inputText.toLowerCase(), 'model');

            let result = '';

            // Analyze component for each model
            for (let i = 0; i < modelIndices.length; i++) {
                const modelIndex = modelIndices[i];
                const nextModelIndex = (i + 1 < modelIndices.length) ? modelIndices[i + 1] : inputText.length;
                const modelText = inputText.substring(modelIndex, nextModelIndex);

                // Find the "Total {component} quantity" line
                let totalQty;
                let totalQtyLine = modelText.match(new RegExp(`total\\s${component}\\squantity\\s-\\s(\\d+)`, 'i'));
                if (totalQtyLine) {
                    totalQty = parseInt(totalQtyLine[1]);
                } else {
                    // Look for the line containing "total {component} quantity" or "{component} details"
                    const lines = modelText.split('\n');
                    for (const line of lines) {
                        if (line.toLowerCase().includes('total') && line.toLowerCase().includes(component) && line.toLowerCase().includes('quantity')) {
                            const qtyMatch = line.match(/(\d+)/);
                            if (qtyMatch) {
                                totalQty = parseInt(qtyMatch[1]);
                                break;
                            }
                        }
                    }
                }

                if (!totalQty) {
                    result += `Model ${i + 1}: No ${component}\n\n`;
                    continue; // Skip this model if total quantity is not found
                }

                // Find the "{Component} details" section and extract quantities
                const detailsIndex = modelText.toLowerCase().indexOf(`${component} details`);
                if (detailsIndex === -1) {
                    result += `Model ${i + 1}: Validation failed - ${component} details section not found.\n\n`;
                    continue; // Skip this model if "{Component} details" section is not found
                }
                const detailsEndIndex = modelText.indexOf('\n\n', detailsIndex);
                if (detailsEndIndex === -1) {
                    result += `Model ${i + 1}: Validation failed - End of ${component} details section not found.\n\n`;
                    continue; // Skip this model if end of "{Component} details" section is not found
                }
                const detailsSection = modelText.substring(detailsIndex, detailsEndIndex);
                const qtyMatches = detailsSection.match(/- (\d+) nos/g);
                if (!qtyMatches) {
                    result += `Model ${i + 1}: Validation failed - No quantities found in ${component} details section.\n\n`;
                    continue; // Skip this model if no quantities are found in "{Component} details" section
                }
                const foundQty = qtyMatches.reduce((sum, match) => {
                    const qty = parseInt(match.match(/(\d+) nos/)[1]);
                    return sum + qty;
                }, 0);

                // Compare found quantity with expected quantity
                if (foundQty === totalQty) {
                    result += `Model ${i + 1}: Validation success\nTotal ${component} quantity - ${totalQty} (expected)\n${component} details - ${foundQty} (found)\n\n`;
                } else {
                    result += `Model ${i + 1}: Validation failed\nTotal ${component} quantity - ${totalQty} (expected)\n${component} details - ${foundQty} (found)\n\n`;
                }
            }

            return result.trim();
        }


        function analyzeComstarNumbering(inputText) {
    let result = '';

    const startingNumber = getNumberFromLine(inputText, 'starting', 'number');
    const endingNumber = getNumberFromLine(inputText, 'ending', 'number');
    const okQuantityMatch = findOkQuantityUnderFinalComstar(inputText);

    if (startingNumber && endingNumber) {
        const difference = endingNumber - startingNumber;
        if (okQuantityMatch !== null && difference === okQuantityMatch) {
            result += `Comstar numbering details validation success\nDifference: ${difference}\nTotal Ok quantity: ${okQuantityMatch}\n\n`;
        } else {
            result += `Comstar numbering details validation failed\nDifference: ${difference}\nTotal Ok quantity: ${okQuantityMatch}\n\n`;
        }
    } else {
        result += `Comstar numbering details validation failed - Starting or ending number not found\n\n`;
    }

    return result;
}

        function findOkQuantityUnderFinalComstar(inputText) {
            const lines = inputText.split('\n');
            let startSearch = false;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].toLowerCase();
                if (line.includes('final') && line.includes('comstar')) {
                    startSearch = true;
                    continue;
                }

                if (startSearch && line.includes('total') && line.includes('ok')) {
                    const numberMatch = line.match(/(\d+)/);
                    if (numberMatch) {
                        return parseInt(numberMatch[1]);
                    }
                }
            }

            return null;
        }

        function getNumberFromLine(inputText, word1, word2) {
            const lines = inputText.split('\n');
            for (const line of lines) {
                if (line.toLowerCase().includes(word1) && line.toLowerCase().includes(word2)) {
                    const numberMatch = line.match(/(\d+)/);
                    if (numberMatch) {
                        return parseInt(numberMatch[1]);
                    }
                }
            }
            return null;
        }


 </script>
</body>
</html>
